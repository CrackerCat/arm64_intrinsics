#define _CRT_SECURE_NO_WARNINGS
#include <inttypes.h>
#include <stdio.h>
#include <string.h>
#include "binaryninjaapi.h"
#include "lowlevelilinstruction.h"

using namespace BinaryNinja;
using namespace std;

// autogenerated static map of key -> msr name
#include "msr.h"

// TODO:
// MSR_IMM - this has a different input width than MSR_REG
// DMB
// DSB


// TODO: figure out if there is a way to make sure these don't collide with
// other plugin authors or binja core
constexpr uint32_t ISB     = 0x4141;
constexpr uint32_t WFI     = 0x4142;
constexpr uint32_t WFE     = 0x4143;
constexpr uint32_t MSR_IMM = 0x4144;
constexpr uint32_t MSR_REG = 0x4145;
constexpr uint32_t MRS     = 0x4146;

constexpr uint32_t MSR_BASE = 0x4200;

class arm64Intrinsics: public ArchitectureHook
{
private:
	// we need a shotgun arm64 decoder
	constexpr uint32_t DecodeIntrinsic(const uint8_t *data, size_t sz)
	{
		if (sz < 4) return 0;

		const uint32_t candidate = *(uint32_t *)data;


		const uint32_t isb      = 0b11010101000000110011000011011111;
		const uint32_t isb_mask = 0b11111111111111111111000011111111;
		if ((candidate & isb_mask) == isb) return ISB;

		const uint32_t wfi = 0b11010101000000110010000001111111;
		if (candidate == wfi) return WFI;

		const uint32_t wfe = 0b11010101000000110010000001011111;
		if (candidate == wfe) return WFE;

		if (candidate >> 20 == 0b110101010001) return MSR_REG;

		const uint32_t msr_imm      = 0b11010101000000000100000000011111;
		const uint32_t msr_imm_mask = 0b11010101000000000100000000011111;
		if ((candidate & msr_imm_mask) == msr_imm) return MSR_IMM;

		if (candidate >> 20 == 0b110101010011) return MRS;

		return 0;
	}

	constexpr uint8_t SrOp0(uint32_t ins)
	{
		return ((ins >> 19) & 0b1) + 2;
	}

	constexpr uint8_t SrOp1(uint32_t ins)
	{
		return (ins >> 16) & 0b111;
	}

	constexpr uint8_t SrOp2(uint32_t ins)
	{
		return (ins >> 5) & 0b111;
	}

	constexpr uint8_t SrXt(uint32_t ins)
	{
		return ins & 0b11111;
	}

	constexpr uint8_t SrCm(uint32_t ins)
	{
		return (ins >> 8) & 0b1111;
	}

	constexpr uint8_t SrCn(uint32_t ins)
	{
		return (ins >> 12) & 0b1111;
	}

	constexpr uint32_t StatusReg(uint8_t o0, uint8_t o1, uint8_t Cn, uint8_t Cm, uint8_t o2)
	{
		return o0 << 14 | o1 << 11 | Cn << 7 | Cm << 3 | o2;
	}

	const char* StatusRegName(uint32_t key)
	{
		return msr[key];
	}

public:
	arm64Intrinsics(Architecture* arm64) : ArchitectureHook(arm64) {}

	/*
	 * First we need to add all the status registers as registers to the
	 * architecture so that our intrinsics have a src (mrs) and a dst (msr)
	 */
	virtual vector<uint32_t> GetAllRegisters() override
	{
		vector<uint32_t> regs = ArchitectureHook::GetAllIntrinsics();

		for (auto const& ii : msr) {
			regs.push_back(MSR_BASE + ii.first);
		}

		return regs;
	}

	virtual vector<uint32_t> GetGlobalRegisters() override
	{
		vector<uint32_t> regs = ArchitectureHook::GetGlobalRegisters();

		for (auto const& ii : msr) {
			regs.push_back(MSR_BASE + ii.first);
		}

		return regs;
	}

	virtual string GetRegisterName(uint32_t reg) override
	{
		uint32_t key = reg - MSR_BASE;

		if (msr.find(key) != msr.end()) {
			return StatusRegName(key);
		}

		return ArchitectureHook::GetRegisterName(reg);
	}

	virtual BNRegisterInfo GetRegisterInfo(uint32_t reg) override
	{
		uint32_t key = reg - MSR_BASE;

		if (msr.find(key) != msr.end()) {
			BNRegisterInfo res;

			res.fullWidthRegister = reg;
			res.offset = 0;
			res.size = 4;
			res.extend = NoExtend;

			return res;
		}

		return ArchitectureHook::GetRegisterInfo(reg);
	}

	virtual vector<uint32_t> GetFullWidthRegisters() override
	{
		vector<uint32_t> regs = ArchitectureHook::GetFullWidthRegisters();

		for (auto const& ii : msr) {
			regs.push_back(MSR_BASE + ii.first);
		}

		return regs;
	}

	/*
	 * Now that we've got our regs added, we can add our intrinsics
	 */

	virtual string GetIntrinsicName(uint32_t intrinsic) override
	{
		switch (intrinsic) {
			case ISB: return "__isb";
			case WFI: return "__wfi";
			case WFE: return "__wfe";
			case MSR_IMM:
			case MSR_REG:
					  return "_WriteStatusReg";
			case MRS: return "_ReadStatusReg";
			default: break;
		}

		return ArchitectureHook::GetIntrinsicName(intrinsic);
	}

	virtual vector<uint32_t> GetAllIntrinsics() override
	{
		vector<uint32_t> intrins = ArchitectureHook::GetAllIntrinsics();

		intrins.push_back(ISB);
		intrins.push_back(WFE);
		intrins.push_back(WFI);
		intrins.push_back(MSR_IMM);
		intrins.push_back(MSR_REG);
		intrins.push_back(MRS);

		return intrins;
	}

	/*
	 * Now we need to define the inputs and outputs to our intrinsics. Since
	 * we're mostly worried about MSR/MRS right now, we're going to define them
	 * as:
	 * reg = msr(x0)
	 * x0 = mrs(reg)
	 *
	 * We need to do this because binja doesn't have a nice way for us to express
	 * intrinsics as msr(reg, x0) easily in the IL's.
	 */

	virtual vector<NameAndType> GetIntrinsicInputs(uint32_t intrinsic) override
	{
		switch (intrinsic) {
			case ISB: return vector<NameAndType> { };
			case WFI: return vector<NameAndType> { };
			case WFE: return vector<NameAndType> { };
			case MSR_IMM: return vector<NameAndType> { NameAndType(Type::IntegerType(4, false)) };
			case MSR_REG: return vector<NameAndType> { NameAndType(Type::IntegerType(8, false)) };
			case MRS: return vector<NameAndType> { NameAndType(Type::IntegerType(4, false)) };
			default: break;
		}

		return ArchitectureHook::GetIntrinsicInputs(intrinsic);
	}

	virtual vector<Confidence<Ref<Type>>> GetIntrinsicOutputs(uint32_t intrinsic) override
	{
		switch (intrinsic) {
			case ISB: return vector<Confidence<Ref<Type>>> { };
			case WFI: return vector<Confidence<Ref<Type>>> { };
			case WFE: return vector<Confidence<Ref<Type>>> { };
			case MSR_IMM:
			case MSR_REG:
					  return vector<Confidence<Ref<Type>>> { Type::IntegerType(4, false) };
			case MRS: return vector<Confidence<Ref<Type>>> { Type::IntegerType(8, false) };
			default: break;
		}

		return ArchitectureHook::GetIntrinsicOutputs(intrinsic);
	}

	virtual bool GetInstructionLowLevelIL(const uint8_t* data, uint64_t addr, size_t& len, LowLevelILFunction& il) override
	{
		switch (DecodeIntrinsic(data, len)) {
			case ISB:
				il.AddInstruction(
						il.Intrinsic(
							vector<RegisterOrFlag> { },
							ISB,
							vector<ExprId> { }));
				break;
			case WFI:
				il.AddInstruction(
						il.Intrinsic(
							vector<RegisterOrFlag> { },
							WFI,
							vector<ExprId> { }));
				break;
			case WFE:
				il.AddInstruction(
						il.Intrinsic(
							vector<RegisterOrFlag> { },
							WFE,
							vector<ExprId> { }));
				break;
			case MSR_REG:
			{
				uint32_t ins = *(uint32_t *)data;

				il.AddInstruction(
						il.Intrinsic(
							vector<RegisterOrFlag> {
							RegisterOrFlag::Register(MSR_BASE + StatusReg(
											SrOp0(ins), SrOp1(ins), SrCn(ins), SrCm(ins), SrOp2(ins))),
							},
							MSR_REG,
							// 34 is the offset into the 64b GPRs from GetAllRegisters
							vector<ExprId> { il.Register(8, 34 + SrXt(ins)) }));
				break;
			}
			case MRS:
			{
				uint32_t ins = *(uint32_t *)data;

				il.AddInstruction(
						il.Intrinsic(
							// 34 is the offset into the 64b GPRs from GetAllRegisters
							vector<RegisterOrFlag> { RegisterOrFlag::Register(34 + SrXt(ins)) },
							MRS,
							vector<ExprId> {
								il.Register(4, MSR_BASE + StatusReg(
											SrOp0(ins), SrOp1(ins), SrCn(ins), SrCm(ins), SrOp2(ins))),
							}));
				break;
			}
			// intrinsic not found, punt to the arch plugin
			case 0:
			default:
				return ArchitectureHook::GetInstructionLowLevelIL(data, addr, len, il);
		}

		len = 4; // all instructions are 4b
		return true;
	}
};

extern "C"
{
	BINARYNINJAPLUGIN void CorePluginDependencies()
	{
		// Make sure we load after the original arm64 plugin loads
		AddRequiredPluginDependency("arch_arm64");
	}

	BINARYNINJAPLUGIN bool CorePluginInit()
	{
		// binja uses both arm64 and aarch64, so we just pick one and use it
		Architecture* arm64_intrin = new arm64Intrinsics(Architecture::GetByName("aarch64"));
		Architecture::Register(arm64_intrin);
		return true;
	}
}
